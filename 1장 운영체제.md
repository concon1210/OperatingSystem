## 운영체제

운영체제의 기능

 

CPU 스케줄링

메모리 관리

디스크 스케줄링

인터럽트, 캐싱

 

CPU 스케줄링

\1.   FCFS(First-Come-First-Served)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

\2.   SJF(Shortest-Job-First)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

\3.   RR(Round Robin)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

 

 

 

메모리 관리

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

 

디스크 스케줄링

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)

프로세스가 디스크 큐에 쌓이게 된다. 디스크는 원판이 회전을 하며 읽혀지고 빨간색 헤드부분으로 읽어진다. 디스크의 효율성 = 헤드 이동 시간과 거리 단축.

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)

FCFS(First-Come-First-Served)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)

SSTF(Shortest Seek Time First)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)

SCAN

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png)

저장장치 계층구조와 캐싱(caching)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png)

플래시 메모리

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png)

운영체제의 종류

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)

 

 

 

운영 체제란?

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image034.png)

운영 체제의 목적

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image036.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image038.png)

운영 체제의 분류

 

동시 작업 가능 여부

사용자의 수

처리 방식

 

동시 작업 가능 여부

단일 작업(single tasking)

한 번에 하나의 작업만 처리

Ms-dos 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음

 

다중 작업(multi tasking)

동시에 두 개 이상의 작업 처리

UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

 

사용자의 수

 

단일사용자(single user)

Ms-dos, MS Windows

 

다중 사용자(multi user)

UNIX, NT server

 

처리 방식

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png)![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image042.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image044.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image046.png)

운영 체제의 예

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image048.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image050.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image052.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)

컴퓨터 시스템 구조

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image056.png)

Mode bit

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image058.png)

Timer

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image060.png)

인터럽트

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image062.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image064.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image066.png)

시스템콜

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image068.png)

 

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image070.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image072.png)

DMA

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image074.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image076.png)

CPU 명령어 = instruction

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image078.png)

타이머

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image080.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image082.png)

프로그램의 실행(메모리 load)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image084.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image086.png)

Virtual memory = Address space 주소공간

자기만의 메모리 주소 공간

당장 필요한 부분은 물리적인 메모리에 올라가고 그렇지 않은 부분은 swap area에 올라가게 된다. 이 중 일부는 코드 같은 일부는 File system에 실행파일 형태로 존재.

0번지부터 시작하는 각 프로세스들만의 주소

 

물리 메모리는 0번지부터 쭉 하나의 주소 운영체제가 낮은 주소에 올라가고 그 위에 프로그램들이 올라가기에 물리적인 주소와 가상의 메모리의 주소는 다른 주소이다.

그래서 주소 변환이 필요하다 그것이 Address translation

주소 변환이 필요하다.

 

프로세스 각각의 Address space에는 구성요소가 있는데 

Code data stack 

Code = 실행파일에 있는 코드가 올라오는 부분 실제 CPU에서 수행할 기계어들이 위치

Data = 데이터가 보관되는 위치 프로그램이 실행되다가 메모리 데이터를 사용하게 될 때 (배열을 잡아 사용하거나 변수를 선언하고 사용할 때) 모든 데이터가 위치하는 것은 아니고 함수 안에 들어가있는 지역 변수와 같은 것은 stack에 위치 

전역 변수나 프로그램이 시작해서 종료될 때까지 남아있는 그런 데이터들이 위치

Stack = 모든 프로그램들이 어떤 언어로 작성되었던 간에 함수 구조로 되어있다 

어떤 함수를 호출하면 그 함수가 끝나면 다시 리턴 되야 하고 그러한 함수 호출과 리턴 데이터가 stack에 저장

 

프로그램의 virtual memory는 code data stack으로 구성된다.

커널도 운영체제 커널도 함수 구조로 되어있고 커널도 code 

 