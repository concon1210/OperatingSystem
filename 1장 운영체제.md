운영체제의 기능

 

CPU 스케줄링

메모리 관리

디스크 스케줄링

인터럽트, 캐싱

 

CPU 스케줄링

\1.   FCFS(First-Come-First-Served)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

\2.   SJF(Shortest-Job-First)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

\3.   RR(Round Robin)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

 

 

 

메모리 관리

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

 

디스크 스케줄링

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)

프로세스가 디스크 큐에 쌓이게 된다. 디스크는 원판이 회전을 하며 읽혀지고 빨간색 헤드부분으로 읽어진다. 디스크의 효율성 = 헤드 이동 시간과 거리 단축.

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)

FCFS(First-Come-First-Served)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)

SSTF(Shortest Seek Time First)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)

SCAN

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png)

저장장치 계층구조와 캐싱(caching)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png)

플래시 메모리

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png)

운영체제의 종류

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)

 

 

 

운영 체제란?

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image034.png)

운영 체제의 목적

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image036.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image038.png)

운영 체제의 분류

 

동시 작업 가능 여부

사용자의 수

처리 방식

 

동시 작업 가능 여부

단일 작업(single tasking)

한 번에 하나의 작업만 처리

Ms-dos 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음

 

다중 작업(multi tasking)

동시에 두 개 이상의 작업 처리

UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

 

사용자의 수

 

단일사용자(single user)

Ms-dos, MS Windows

 

다중 사용자(multi user)

UNIX, NT server

 

처리 방식

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png)![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image042.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image044.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image046.png)

운영 체제의 예

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image048.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image050.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image052.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)

컴퓨터 시스템 구조

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image056.png)

Mode bit

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image058.png)

Timer

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image060.png)

인터럽트

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image062.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image064.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image066.png)

시스템콜

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image068.png)

 

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image070.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image072.png)

DMA

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image074.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image076.png)

CPU 명령어 = instruction

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image078.png)

타이머

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image080.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image082.png)

프로그램의 실행(메모리 load)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image084.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image086.png)

Virtual memory = Address space 주소공간

자기만의 메모리 주소 공간

당장 필요한 부분은 물리적인 메모리에 올라가고 그렇지 않은 부분은 swap area에 올라가게 된다. 이 중 일부는 코드 같은 일부는 File system에 실행파일 형태로 존재.

0번지부터 시작하는 각 프로세스들만의 주소

 

물리 메모리는 0번지부터 쭉 하나의 주소 운영체제가 낮은 주소에 올라가고 그 위에 프로그램들이 올라가기에 물리적인 주소와 가상의 메모리의 주소는 다른 주소이다.

그래서 주소 변환이 필요하다 그것이 Address translation

주소 변환이 필요하다.

 

프로세스 각각의 Address space에는 구성요소가 있는데 

Code data stack 

Code = 실행파일에 있는 코드가 올라오는 부분 실제 CPU에서 수행할 기계어들이 위치

Data = 데이터가 보관되는 위치 프로그램이 실행되다가 메모리 데이터를 사용하게 될 때 (배열을 잡아 사용하거나 변수를 선언하고 사용할 때) 모든 데이터가 위치하는 것은 아니고 함수 안에 들어가있는 지역 변수와 같은 것은 stack에 위치 

전역 변수나 프로그램이 시작해서 종료될 때까지 남아있는 그런 데이터들이 위치

Stack = 모든 프로그램들이 어떤 언어로 작성되었던 간에 함수 구조로 되어있다 

어떤 함수를 호출하면 그 함수가 끝나면 다시 리턴 되야 하고 그러한 함수 호출과 리턴 데이터가 stack에 저장

 

프로그램의 virtual memory는 code data stack으로 구성된다.

커널도 운영체제 커널도 프로그램이기에 함수 구조로 되어있고 커널도 code data stack으로 구성되어 있다.

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image088.png)

커널의 주소 공간을 좀 더 옆으로 해서 code data stack 으로 나열

운영체제는 시스템 안에 있는 자원을 효율적으로 관리.

코드가 운영체제 커널에 함수 형태로 존재해야 한다. 그런 것이 있고 

사용자에게 편리한 인터페이스 제시(커널에 함수로 프로그램 되어 있다.)

사용자 프로그램이 CPU에서 돌아가다가 인터럽트가 들어왔을 때 뭘 처리해야는지 커널에 존재

CPU에서 사용자 프로그램을 수행할 수 없는 특권 명령에 기계어를 실행할 때 운영체제에게 대신 해달라고 요청 할 때 대표적인 게 IO

모든 IO작업은 특권명령으로 묶여있기 때문에 사용자 프로그램이 디스크에서 파일을 읽어 와야 한다 직접 할 수 없어 운영체제에게 대신 해달라고 요청하여 파일을 읽은 그런 코드들.

 

운영체제는 하드웨어 자원도 관리하지만 지금 시스템 안에서 돌아가는 모든 프로세스들을 관리

운영체제 데이터 영역에는 모든 하드웨어들을 관리하기 위한 자료구조를 가지고 있고 모든 프로세스들 현재 실행중인 모든 프로세스들을 관리하기 위한 자료구조를 가지고 있다. (PCB)

Process control block

현재 프로세스가 10개가 돌아간다면 PCB 또한 10개를 만들어서 프로세스를 관리

 

프로그램A가 실행되다 운영체제에게 서비스를 요청할 수 있고 프로그램B가 실행되다 요청할 수 있다.

프로그램에 의해서 운영체제는 호출이 되기 때문에 누구의 서비스를 수행하기 위해 운영체제 코드가 실행되는가에 따라서 커널의 스택은 각 프로세스마다 별로도 두고 있다.

 

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image090.png)

내가 정의한 함수이든 라이브러리 함수이든 내 프로그램안에 들어가게 된다.

반대로 커널 함수는 운영체제 안에 있는 함수이다.

프로그램 안에 있는 함수가 아닌 커널 안에 존재

커널 함수의 호출 = 시스템 콜

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image092.png)

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image094.png)

하나의 프로그래밍 시작이 되어서 종료될 때까지 어떤 과정을 거치느냐

내가 정의한 함수를 호출 할 때도 있고 내가 정의 하지 않았지만 누가 만들어 놓은 라이브러리 함수를 사용할 때도 있고 운영체제 커널의 함수를 불러다가 쓸 때도 있고 프로그램을 만드는 사람을 여러 함수를 가져다 사용

그렇지만 프로그램이 진행되면서 CPU의 제어권이 어떻게 바뀌는지 보면은 내가 정의한 함수나 라이브러리 함수가 호출이 될 때면 내 주소 공간에 있는 code가 유저모드에서 실행

시스템 콜을 부르게 되면 CPU 제어권이 운영체제한테 넘어가서 커널모드에서 운영체제에 주소 공간에 있는 code가 실행

 

유저모드(mode bit 1) 커널모드(mode bit 0)

 

 

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image096.png)

실행중인 프로그램 프로세스라고 한다.

프로세스의 문맥(context)

실행에서 종료까지

운영체제는 context를 중요시 생각한다.

\1.   CPU에서 어디까지 수행했는가 (CPU 수행 상태를 나타내는 하드웨어 문맥)

Program Counter 값

각종 register 값 (현재 register에 어떤 값을 넣고 있었는가 하는게 CPU context)

\2.   프로세스의 주소 공간

Code, data, stack

\3.   프로세스 관련 커널 자료 구조

PCB(Process Control Block) 

각각의 프로세스를 운영체제가 관리하면서 가지고 있는 자료구조(CPU를 얼마나 썼는지 메모리를 어떻게 썼는지 그런 정보의 종합)

Kernel stack

프로세스 마다 별도의 커널 스택을 사용

이 프로세스의 문맥을 파악하기 위해 그 커널 스택에 어떤 내용이 들어가있는지 프로세스의 현재 상태를 나타내는데 좋은 지표

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image098.png)

프로세스는 여러가지 상태가 존재한다. 

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image100.png)

CPU는 하나 밖에 없기 때문에 CPU에서 기계어를 수행하는 프로세스는 하나만이 존재한다.

CPU를 잡고 사용하고 있는 프로세스를 Running 상태에 있다 라고 한다.

CPU를 쓰고 싶은데 기다리고 있는 프로세스들을 Ready 상태에 있다 라고 한다.

 

CPU가 있어봐야 동작이 불가능한 프로세스(디스크에서 파일을 읽어야한다던가)

Blocked 상태에 있다 라고 한다.(wait, sleep)

기다림의 종류

CPU를 주어도 당장 instruction을 수행할 수 없는 상태

Process 자신이 요청한 event(I/o)가 즉시 만족되지 않아 이를 기다리는 상태

 

New: 프로세스가 생성중인 상태

Terminated: 수행(execution)이 끝난 상태

 

Disk I/O queue에 block 상태의 프로세스 대기

 

운영체제가 다음 번의 CPU를 줄 때 Ready queue에 있는 프로세스를 준다.

Disk I/O queue에 block 상태의 프로세스에는 주지 않는다.

결국에는 오래 걸리는 작업이 해소가 되어야 Ready queue로 넘어올 수 있다.

 

작업이 해소가 되면 어떻게 되나

예를 들면 키보드 입력을 기다는 프로세스가 있었는데 입력이 들어왔다.

하면 운영체제가 Ready queue로 넘겨줘야 하는데 어떤 과정이 필요한가

 

운영체제가 원하는 이벤트가 끝났다고 바로 CPU가 넘어가지 않는다

Interrupt가 필요함

키보드 컨트롤러가 CPU한테 인터럽트를 걸고 그러면 CPU 제어권이 운영체제한테 넘어옴

그러면 키보드 인터럽트를 확인하고 blocked 상태에 두지 않고 ready 상태로 넘겨준다

 

오래걸리는 작업은 하드웨어 작업만이 있는 것은 아니다.

공유 데이터가 있을 수 있다.

프로세스끼리 같이 쓰는 데이터를 공유데이터라고 한다.

동시에 사용할 경우 문제가 생길 확률이 높아 하나가 사용중이라면 대기 후에 사용해야 한다.(대기 상태 blocked)

Blocked 상태는 꼭 하드웨어가 오래 걸려야만 되는 것은 아니다.

오래 걸리는 작업, 내가 원하는 이벤트 이런 것들이 발생하지 않아서 CPU를 줘도 일을 못하는 그런 상태

 

여러 큐를 둬서 프로세스의 상태가 어떻고 이런 것을 운영체제가 PCB를 통해서 관리 한다.

 

프로세스 상태도

![img](file:///C:/Users/fasol/AppData/Local/Temp/msohtmlclip1/01/clip_image102.png)

 

변화도

 

프로세스가 생성 중인 상태 NEW

프로세스가 종료 중인 상태 terminated

 

프로세스가 아직 생성이 안되었으면 프로세스가 아니기에 생성 중인 거고 프로세스가 이미 종료가 되었다면 그것 또한 프로세스가 아니다.